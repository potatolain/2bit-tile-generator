{"version":3,"sources":["constants/tile-constants.js","constants/palette-constants.js","components/palette-color-preview.js","components/palette-preview.js","components/tile-setting.js","components/tiled-image.js","components/map-preview-button.js","App.js","reportWebVitals.js","index.js","services/image-generator.js"],"names":["IMAGE_WIDTH","IMAGE_HEIGHT","AVAILABLE_TILE_TYPES","DEFAULT_TILE_TYPE","TILE_BACKGROUND_COLORS","grass","water","lava","rock","brick","hole","plant","block","sand","bridge","ladder","stairs","tile","TILE_NAMES","TILE_PREVIEW_IDS","TILE_OPTIONS","name","type","defaultValue","min","max","disabled","step","TILE_PREVIEW_MAP","availablePalettes","paletteData","getPalette","idOrName","PaletteColorPreview","className","style","backgroundColor","this","props","color","React","Component","PalettePreview","palette","map","a","toString","padStart","TileSetting","setting","state","tileTypeId","updateTileState","reloadFromProps","nextProps","setState","b","c","label","value","tileProps","onSlChange","e","target","n","checked","console","error","TiledImage","allSrc","tileId","id","tileImages","src","i","alt","MapPreviewButton","imageRef","createRef","mapImage","ImageGenerator","generateMapPreview","img","current","show","content","onClick","showDialog","ref","App","tileType","currentTileImg","builtTileImages","forEach","t","opt","undefined","val","Math","floor","random","lastTileType","localStorage","getItem","info","length","generateTileImage","reloadImage","newState","force","Palette","generateImage","res","getCurrentTileImage","event","setItem","typeName","generateFullSet","document","createElement","href","download","click","downloadAll","reRandomize","updateTileType","slot","process","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById","modulus","getRandomImageCoords","image","x","bitmap","width","y","height","tileOpt","Promise","resolve","reject","Jimp","err","drawGrass","drawWater","drawBrick","drawBlock","drawHole","drawPlant","drawRock","drawLava","drawSand","drawBridge","drawLadder","drawStairs","warn","getBase64Async","setPixelColor","originX","originY","depthR","scan","idx","dx","dy","xDiff","yDiff","row1Lines","row2Lines","push","rowNum","indexOf","tileSize","h","borderWidth","fuzzWidth","angle","x1","y1","r","cos","PI","sin","round","imgY","hitLeft","hitMid","hitRight","colorCount","imgX","getPixelColor","shadowX","freckleCount","fx","fy","coords","fxx","fyy","read","rockImg","blit","frequency","offset","waveWidth","abs","currColor","stepHeight","imageState","thisB64","substr","Buffer","from","thisImg","sqrt","drawState","pos","notDrawn","filter","join"],"mappings":"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","file":"static/js/main.ced82b64.chunk.js","sourcesContent":["export const IMAGE_WIDTH = 16;\nexport const IMAGE_HEIGHT = 16;\n\nexport const AVAILABLE_TILE_TYPES = [\n  'block',\n  'brick',\n  'bridge', \n  'plant', // Aka \"bush\"\n  'grass', \n  'hole',\n  'ladder',\n  'lava', \n  'rock', \n  'sand',\n  'stairs',\n  'tile',\n  'water',\n];\n\nexport const DEFAULT_TILE_TYPE = 'block';\n\nexport const TILE_BACKGROUND_COLORS = {\n  grass: 3,\n  water: 2,\n  lava: 3,\n  rock: 3, \n  brick: 2,\n  hole: 0,\n  plant: 3,\n  block: 3,\n  sand: 0,\n  bridge: 0,\n  ladder: 0,\n  stairs: 0,\n  tile: 3\n};\n\nexport const TILE_NAMES = {\n  grass: 'Grass',\n  water: 'Water',\n  lava: 'Lava',\n  block: 'Block',\n  brick: 'Brick Wall',\n  rock: 'Rock',\n  hole: 'Hole / Gap',\n  plant: 'Bush',\n  sand: 'Sand',\n  bridge: 'Bridge',\n  ladder: 'Ladder',\n  stairs: 'Stairs',\n  tile: 'Tile'\n}\n\nexport const TILE_PREVIEW_IDS = {\n  grass: [ \n    'grass', 'grass', 'grass', \n    'grass', 'grass', 'grass', \n    'grass', 'grass', 'grass',\n  ],\n  water: [\n    'water', 'water', 'water',\n    'water', 'water', 'water',\n    'water', 'water', 'water',\n  ],\n  lava: [\n    'sand', 'lava', 'lava',\n    'sand', 'lava', 'lava',\n    'sand', 'lava', 'lava',\n  ],\n  block: [\n    'block', 'block', 'block',\n    'block', 'grass', 'grass',\n    'block', 'grass', 'grass',\n  ],\n  brick: [\n    'brick', 'brick', 'brick',\n    'brick', 'brick', 'brick',\n    'grass', 'grass', 'grass', \n  ],\n  rock: [\n    'sand', 'sand', 'sand',\n    'rock', 'rock', 'rock',\n    'sand', 'sand', 'sand',\n  ],\n  hole: [\n    'grass', 'grass', 'grass',\n    'grass', 'hole', 'grass',\n    'grass', 'grass', 'grass',\n  ],\n  plant: [\n    'grass', 'grass', 'grass',\n    'grass', 'plant', 'grass',\n    'grass', 'grass', 'grass',\n  ],\n  sand: [\n    'sand', 'sand', 'sand',\n    'sand', 'sand', 'sand',\n    'sand', 'sand', 'sand',\n  ],\n  bridge: [\n    'water', 'water', 'water',\n    'bridge', 'bridge', 'bridge',\n    'water', 'water', 'water',\n  ],\n  ladder: [\n    'rock', 'ladder', 'rock',\n    'rock', 'ladder', 'rock',\n    'grass', 'grass', 'grass'\n  ],\n  stairs: [\n    'grass', 'grass', 'grass',\n    'grass', 'stairs', 'grass',\n    'grass', 'grass', 'grass',\n  ],\n  tile: [\n    'tile', 'tile', 'tile',\n    'tile', 'tile', 'tile',\n    'tile', 'tile', 'tile',\n  ]\n}\n\nexport const TILE_OPTIONS = {\n  grass: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Green'},\n    {name: 'Short Blades', min: 0, max: 10, type: 'range', defaultValue: 1},\n    {name: 'Tall Blades', min: 0, max: 10, type: 'range', defaultValue: 0},\n    {name: 'Triangles', min: 0, max: 8, type: 'range', defaultValue: 4}\n  ],\n  water: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Blue'},\n    {name: 'Lines', min: 2, max: 4, type: 'range'},\n    // Couldn't quite get what I wanted out of this - the areas kind of need to be relative to the lines, and \n    // that's a bit more complex than I'd hoped.\n    {name: 'Deeper Areas', min: 0, max: 3, type: 'range', disabled: true, defaultValue: 0}\n  ],\n  lava: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Frequency', min: 15, max: 25, type: 'range' },\n    {name: 'Offset', min: 0, max: 15, type: 'range'},\n    {name: 'Wave Width', min: 4, max: 8, type: 'range'}\n  ],\n  rock: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Yellow'},\n    {name: 'Rock Size', min: 3, max: 7, type: 'range'},\n    {name: 'Rock Color', type: 'color', defaultValue: 2},\n    {name: 'Rock Highlight Color', type: 'color', defaultValue: 3}\n  ],\n  brick: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Brick Width', min: 5, max: 12, type: 'range'},\n    {name: 'Brick Height', min: 2, max: 12, type: 'range'},\n    {name: 'Brick Color', type: 'color', defaultValue: 2}\n  ],\n  block: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Height', min: 4, max: 8, type: 'range'}\n  ],\n  tile: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Height', min: 2, max: 3, type: 'range'}\n  ],\n  hole: [\n    {name: 'Palette', type: 'palette', defaultValue: 'Gameboy'},\n    {name: 'Hole Size', min: 6, max: 14, type: 'range', step: 2},\n    {name: 'Fuzz Area', min: 1, max: 2, type: 'range', defaultValue: 1}\n  ],\n  plant: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Green'},\n    {name: 'Bush Size', min: 3, max: 6, type: 'range'},\n    {name: 'Bush Color', type: 'color', defaultValue: 2},\n    {name: 'Freckle Color', type: 'color', defaultValue: 1},\n    {name: 'Freckle Count', min: 2, max: 8, type: 'range'},\n    {name: 'Freckle Size', min: 1, max: 2, type: 'range', defaultValue: 1}\n  ],\n  sand: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Yellow'},\n    {name: 'Frequency', min: 15, max: 75, type: 'range' },\n    {name: 'Offset', min: 0, max: 15, type: 'range'},\n    {name: 'Wave Width', min: 3, max: 12, type: 'range'}\n  ],\n  bridge: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Board Width', min: 3, max: 9, type: 'range', step: 2, defaultValue: 7},\n    {name: 'Border Width', min: 0, max: 2, type: 'range', defaultValue: 1},\n    {name: 'Board Color', type: 'color', defaultValue: 1},\n    {name: 'Separator Color', type: 'color', defaultValue: 0},\n  ],\n  ladder: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Blue'},\n    {name: 'Step Width', min: 3, max: 9, type: 'range', step: 2, defaultValue: 3},\n    {name: 'Border Width', min: 0, max: 2, type: 'range', defaultValue: 1},\n    {name: 'Step Color', type: 'color', defaultValue: 3},\n    {name: 'Separator Color', type: 'color', defaultValue: 1},\n  ],\n  stairs: [\n    {name: 'Palette', type: 'palette', defaultValue: 'NES Default Red'},\n    {name: 'Step Width', min: 3, max: 9, type: 'range', step: 2, defaultValue: 7},\n    {name: 'Step Height', min: 1, max: 3, type: 'range'},\n    {name: 'Border Width', min: 0, max: 2, type: 'range', defaultValue: 1},\n    {name: 'Step Color', type: 'color', defaultValue: 1},\n    {name: 'Separator Color', type: 'color', defaultValue: 0},\n  ],\n\n\n};\n  \nexport const TILE_PREVIEW_MAP = [\n  'brick', 'brick', 'ladder', 'brick', 'grass', 'grass', 'grass', 'grass', 'block', 'tile', 'tile', 'tile',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'plant', 'plant', 'grass', 'block', 'tile', 'stairs', 'tile',\n  'grass', 'grass', 'plant', 'plant', 'grass', 'plant', 'plant', 'grass', 'block', 'tile', 'tile', 'tile',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'block', 'block', 'block', 'block',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass',\n  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass',\n  'sand' , 'sand' , 'sand' , 'sand' ,  'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass',\n  'water', 'water', 'water', 'sand' , 'sand', 'grass', 'grass', 'grass', 'grass', 'grass', 'lava', 'lava',\n  'water', 'water', 'water', 'sand' , 'sand', 'sand', 'grass', 'grass', 'grass', 'grass', 'lava', 'lava',\n  'bridge', 'bridge', 'bridge', 'sand' , 'sand', 'sand', 'sand', 'hole', 'sand', 'sand', 'lava', 'lava',\n  'water', 'water', 'water', 'sand' , 'rock', 'sand', 'sand', 'hole', 'sand', 'sand', 'lava', 'lava',\n];","export const availablePalettes = [\n    'Gameboy',\n    'NES Default Red',\n    'NES Default Blue',\n    'NES Default Green',\n    'NES Default Yellow'\n];\n\nexport const paletteData = {\n    // NOTE: These colors are exact matches that gbtd understands. Don't change just to make pretty!\n    // (or at least make a separate palette)\n    'Gameboy': [0x000000ff, 0x808080ff, 0xc0c0c0ff, 0xffffffff],\n    'NES Default Blue': [0x000000ff, 0x00008fff, 0x4488ffff, 0x99ccffff],\n    'NES Default Red': [0x000000ff, 0x550000ff, 0x993300ff, 0xdd6644ff],\n    'NES Default Green': [0x000000ff, 0x113300ff, 0x336600ff, 0x77bb00ff],\n    'NES Default Yellow': [0x000000ff, 0x666600ff, 0xbbaa00ff, 0xeedd88ff]\n}\n\nexport const getPalette = (idOrName) => {\n    if (typeof idOrName === 'string') {\n        return paletteData[idOrName];\n    } else {\n        return paletteData[availablePalettes[idOrName]];\n    }\n}","import React from 'react';\nimport './palette-color-preview.css';\n\n// Given a hex color, create a component with that as the background color\n// props: \n// - color: A hex color in rgba format -including alpha. Example: 0xff00ffff\nexport default class PaletteColorPreview extends React.Component {\n\n  render() {\n    return <div className=\"palette-color-preview\" style={{backgroundColor: '#' + this.props.color}}></div>;\n  }\n}","import React from 'react';\nimport './palette-preview.css';\n\nimport PaletteColorPreview from './palette-color-preview';\n\n// Given an array of colors in rgba hex numeral format, draw the palette as dom elements.\n// Props:\n// - palette: An array of colors, in hex format, including alpha. eg 0xff00ffff\nexport default class PalettePreview extends React.Component {\n  render() {\n    return <div className=\"palette-preview\">\n      {this.props.palette.map(a => <PaletteColorPreview key={'prev-' + a} color={a.toString(16).padStart(8, '0')}></PaletteColorPreview>)}\n    </div>;\n  }\n}","import React from 'react';\nimport './tile-setting.css';\n\nimport SlRadio from '@shoelace-style/react/dist/radio';\nimport SlRadioGroup from '@shoelace-style/react/dist/radio-group';\nimport SlRange from '@shoelace-style/react/dist/range';\nimport SlSelect from '@shoelace-style/react/dist/select';\nimport SlMenuItem from '@shoelace-style/react/dist/menu-item';\n\nimport { availablePalettes, getPalette } from '../constants/palette-constants';\n\nimport PaletteColorPreview from './palette-color-preview';\nimport PalettePreview from './palette-preview';\n\n// Given a setting property (such as those defined in tile-constants), render it as a configurable setting.\n// Available types are: range, color, and palette\n// props: \n// - setting: The settings object from constants. Keys detailed there\n// - state: The application state surrounding this thing. This is kind of clunky, and a workaround for redux!\n// - tileTypeId: A 'type' of tile, the key for the settings object.\nexport default class TileSetting extends React.Component {\n  setting = null;\n  state = null;\n  tileTypeId = null;\n  updateTileState = () => {};\n  constructor(props) {\n    super(props);\n    this.state = props.state;\n    this.reloadFromProps(props);\n  }\n\n  // Make sure this component always refreshes when props change.\n  // NOTE: We would be far better served by a redux pattern here, but that's more effort than I'd care\n  // to put in at this stage. At some point we might want to migrate to something better.\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    this.reloadFromProps(nextProps);\n    this.setState(nextProps.state);\n  }\n\n  reloadFromProps(props) {\n    this.setting = props.setting;\n    this.tileTypeId = props.tileTypeId;\n    this.updateTileState = (a, b, c) => {\n        props.updateTileState(a, b, c);\n    };\n  }\n\n  render() {\n    const setting = this.setting;\n\n    if (setting.disabled || setting === null) { return <span key={\"disabled-setting-\" + setting.type + setting.name}></span>; }\n    switch (setting.type) {\n      case 'range':\n        // This could probably be a component of its\n        return <div className=\"tile-option\" key={\"range-\" + setting.type + setting.name}>\n            <SlRange key={this.tileTypeId + setting.name} \n              min={setting.min} \n              max={setting.max} \n              step={setting.step || 1} \n              label={setting.name} \n              value={this.state.tileProps[this.tileTypeId][setting.name]} \n              onSlChange={e => this.updateTileState(this.tileTypeId, setting.name, e.target.value)}>\n            </SlRange>\n            <div className=\"below-range\">\n              <small className=\"left\">{setting.min}</small>\n              <small className=\"mid\">Current: {this.state.tileProps[this.tileTypeId][setting.name]}</small>\n              <small className=\"right\">{setting.max}</small>\n            </div>\n          </div>;\n      case 'color':\n        return <div className=\"tile-option\" key={\"palette-\" + setting.type + setting.name}>\n          <SlRadioGroup label={setting.name}>\n            {[0, 1, 2, 3].map(n => {\n              return <SlRadio \n                  value={n} \n                  checked={this.state.tileProps[this.tileTypeId][setting.name] === n ? true : false} \n                  key={\"palette-color\" + setting.type + setting.name + '-' + n} \n                  onSlChange={e => e.target.checked ? this.updateTileState(this.tileTypeId, setting.name, n) : null}\n                >\n                  Color {n+1} \n                  <PaletteColorPreview color={getPalette(this.state.tileProps[this.tileTypeId]['Palette'])[n].toString(16).padStart(8, '0')}></PaletteColorPreview>\n                </SlRadio>\n            })}\n          </SlRadioGroup>\n        </div>\n      case 'palette':\n        return <div className=\"tile-option\" key={'palette-' + setting.type + setting.name}>\n          <SlSelect \n            label=\"Palette Color\" \n            value={this.state.tileProps[this.tileTypeId][setting.name]}\n            onSlChange={e => this.updateTileState(this.tileTypeId, setting.name, e.target.value)}>\n              {availablePalettes.map(a => <SlMenuItem key={a} value={a}>{a} <PalettePreview palette={getPalette(a)}></PalettePreview></SlMenuItem>)}\n          </SlSelect>\n        </div>\n      default:\n        console.error(`Unknown tile option type \"${setting.type}\" found!`, setting);\n        return <span></span>;\n    }\n\n  }\n}","import React from 'react';\nimport './tiled-image.css';\n\nimport { TILE_PREVIEW_IDS } from '../constants/tile-constants';\n\n// Renders an image in a tiled pattern, sizeXsize wide\n// Props:\n// - tileId: The id of the tile to render, looked up from constants\n// - tileImages: Collection of images to use for the given ids\nexport default class TiledImage extends React.Component {\n  render() {\n    const allSrc = TILE_PREVIEW_IDS[this.props.tileId].map(id => this.props.tileImages[id]);\n    return <div className=\"tile-preview-collection\">\n      {allSrc.map((src, i) => <img alt=\"\" src={src} key={'preview-' + i}></img>)}\n    </div>\n  }\n}","import SlButton from '@shoelace-style/react/dist/button';\nimport SlDialog from '@shoelace-style/react/dist/dialog';\nimport SlTooltip from '@shoelace-style/react/dist/tooltip';\nimport React from 'react';\n\nimport ImageGenerator from '../services/image-generator';\n\nimport './map-preview-button.css';\n\n// Renders a preview map with the given images. simulates a simple game map\n// Props:\n// - tileImages: Collection of images to use for the given ids\nexport default class MapPreviewButton extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.imageRef = React.createRef();\n    this.state = {mapImage: null};\n  }\n\n  async showDialog() {\n    const img = await ImageGenerator.generateMapPreview(this.props.tileImages);\n    this.setState({mapImage: img});\n    // This should always be set - I used the ? to avoid issues with some hacky test code I wrote\n    this.imageRef?.current?.show();\n  }\n\n\n  render() {\n    return <div style={{'display': 'inline-block'}}>\n      <SlTooltip content=\"Show a preview image using all of the tiles\">\n        <SlButton onClick={() => this.showDialog()}>Preview as map</SlButton>\n      </SlTooltip>\n      <SlDialog label=\"Map Preview\" ref={this.imageRef} className=\"map-preview-dialog\">\n        <img alt=\"Map Preview\" src={this.state.mapImage}></img>\n      </SlDialog>\n    </div>;\n    \n  }\n}","import React from 'react';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/themes/base.css';\nimport SlButton from '@shoelace-style/react/dist/button';\nimport SlSelect from '@shoelace-style/react/dist/select';\nimport SlMenuItem from '@shoelace-style/react/dist/menu-item';\nimport SlTooltip from '@shoelace-style/react/dist/tooltip';\n\n// Services\nimport ImageGenerator from './services/image-generator';\n\n// Custom components\nimport TileSetting from './components/tile-setting';\nimport TiledImage from './components/tiled-image';\nimport MapPreviewButton from './components/map-preview-button';\n\n// Constants\nimport { TILE_NAMES, TILE_OPTIONS, AVAILABLE_TILE_TYPES, DEFAULT_TILE_TYPE } from './constants/tile-constants';\nimport { getPalette } from './constants/palette-constants';\n\nimport './App.css';\n// Huge app component that could probably be broken down well if I got smart with a Store for state\nclass App extends React.Component {\n\n  // Initializer, mostly sets up initial state of the application\n  constructor(props) {\n    super(props);\n    this.state = {\n      tileType: DEFAULT_TILE_TYPE,\n      tileProps: {},\n      // Default palette, if one is not provided via options.\n      palette: getPalette(0),\n      // Transparent 1px gif so we don't show a broken image\n      currentTileImg: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\n      builtTileImages: {}\n    }\n\n    // NOTE: This logic is almost-duplicated in the reRandomize method\n    AVAILABLE_TILE_TYPES.forEach(t => {\n\n      // Seriously, it's a constructor. The react docs do this. Calm down, eslint.\n      // eslint-disable-next-line\n      this.state.tileProps[t] = {};\n\n      TILE_OPTIONS[t].forEach(opt => {\n        if (opt.defaultValue !== undefined) {\n          // eslint-disable-next-line\n          this.state.tileProps[t][opt.name] = opt.defaultValue;\n        } else if (opt.min !== undefined && opt.max !== undefined) {\n          let val = Math.floor(Math.random() * (opt.max - opt.min +1)) + opt.min;\n\n          // Enforce the step size in randomization\n          if (opt.step) { \n            val -= (val % opt.step); \n          }\n          // es-lint-disable-next-line\n          this.state.tileProps[t][opt.name] = val;\n        }\n      });\n      this.state.builtTileImages[t] = null;\n    });\n\n\n    // Try to retrieve the last tile you were using to restore state\n    try {\n      const lastTileType = localStorage.getItem('2bit-tile-generator__tileType');\n      if (lastTileType !== null) {\n        this.state.tileType = lastTileType;\n      }\n    } catch (e) {\n      console.info('Failed getting information from localStorage, sticking to default', e);\n    }\n  }\n\n  // Generate the images as soon as this is rendered (else we'll call setState too early)\n  async componentDidMount() {\n    for (let i = 0; i < AVAILABLE_TILE_TYPES.length; i++) {\n      await this.generateTileImage(AVAILABLE_TILE_TYPES[i], false);\n    }\n\n    this.reloadImage();\n  }\n\n  // NOTE: This logic is almost-duplicated in the constructor, with defaults and without the disabled check.\n  reRandomize() {\n    let newState = {tileProps: {...this.state.tileProps}};\n    AVAILABLE_TILE_TYPES.forEach(t => {\n      newState.tileProps[t] = {...this.state.tileProps[t]};\n      TILE_OPTIONS[t].forEach(opt => {\n        if (!opt.disabled) {\n          if (opt.min !== undefined && opt.max !== undefined) {\n            let val = Math.floor(Math.random() * (opt.max - opt.min + 1)) + opt.min;\n\n            // Enforce the step sizein randomization\n            if (opt.step) { \n              val -= (val % opt.step); \n            }\n\n            newState.tileProps[t][opt.name] = val;\n          }\n        }\n      });\n    });\n    this.setState(newState, this.reloadImage);\n  };\n\n  async generateTileImage(tileType, force = false) {\n    let palette = this.state.palette;\n    if (this.state.tileProps[tileType].Palette) {\n      palette = getPalette(this.state.tileProps[tileType].Palette);\n    }\n    if (this.state.builtTileImages[tileType] === null || force) {\n      let res = await ImageGenerator.generateImage(tileType, this.state.tileProps[tileType], palette);\n      this.setState({builtTileImages: {\n        ...this.state.builtTileImages,\n        [tileType]: res\n      }});\n      return res;\n    }\n    return this.state.builtTileImages[tileType];\n\n  }\n\n  // Redraw the image based on current state.\n  async getCurrentTileImage(force = false) {\n    return await this.generateTileImage(this.state.tileType, force);\n  }\n\n  // Rebuild the image shown on the page from available settings.\n  async reloadImage(force = true) {\n    this.setState({currentTileImg: await this.getCurrentTileImage(force)});\n  }\n\n  // Helper function to do exactly what it says. Regenerates the image when it's done.\n  updateTileType(event) {\n    this.setState({tileType: event.target.value}, () => this.reloadImage(false));\n    localStorage.setItem('2bit-tile-generator__tileType', event.target.value);\n  }\n\n  // Helper to update state values from the various components that we support.\n  updateTileState(typeName, name, value) {\n    // Test to make sure the value changed to avoid infinite loops from radio buttons triggering this repeatedly\n    if (this.state.tileProps[typeName][name] === value) { \n      return;\n    }\n\n    // React will stomp any nested objects when you use this, so we have to bring in the old state\n    this.setState({\n      tileProps: {\n        ...this.state.tileProps,\n        [typeName]: {\n          ...this.state.tileProps[typeName],\n          [name]: value\n        }\n      }\n    }, this.reloadImage);\n  }\n\n  async downloadAll() {\n    // First, loop over all images and make sure we've generated them\n    for (let i = 0; i < AVAILABLE_TILE_TYPES.length; i++) {\n      await this.generateTileImage(AVAILABLE_TILE_TYPES[i]);\n    }\n\n    const img = await ImageGenerator.generateFullSet(this.state.builtTileImages);\n\n    // Force a download, the new old-fashioned way\n    let a = document.createElement(\"a\");\n    a.href = img; \n    a.download = \"Tileset.png\";\n    a.click();\n  }\n\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <h1>2Bit Tile Generator</h1>\n        </header>\n        <section>\n\n          <div className=\"control-bar\">\n            <MapPreviewButton tileImages={this.state.builtTileImages}></MapPreviewButton>\n            <SlTooltip content=\"Download a single png file with all tiles\">\n              <SlButton onClick={() => this.downloadAll()}>Download Tile Strip</SlButton>\n            </SlTooltip>\n            <SlTooltip content=\"Randomize the settings for all tiles.\">\n              <SlButton onClick={() => this.reRandomize()}>Randomize Settings</SlButton>\n            </SlTooltip>\n            <SlTooltip content=\"Regenerate tile image with the current settings\">\n              <SlButton onClick={() => this.reloadImage(true)}>Regenerate</SlButton>\n            </SlTooltip>\n          </div>\n\n          <div className=\"configurator\">\n            <div className=\"left\">\n              <h3>Tile Preview</h3>\n\n              <h4>Single</h4>\n              <img className=\"tile-preview\" alt=\"Tile Preview\" src={this.state.currentTileImg}></img>\n              <h4>Tiled</h4>\n              <TiledImage tileId={this.state.tileType} tileImages={this.state.builtTileImages}></TiledImage>\n              <div className=\"dl-bar\">\n                <SlButton href={this.state.currentTileImg} download={this.state.tileType + '.png'}>Download</SlButton>\n              </div>\n            </div>\n            <div className=\"right\">\n              <h3>Tile Configuration</h3>\n              <div className=\"tile-option\">\n                <SlSelect label=\"Tile Type\" value={this.state.tileType} onSlChange={e => this.updateTileType(e)} className=\"tile-type-select\">\n                  {AVAILABLE_TILE_TYPES.map(a => <SlMenuItem key={a} value={a}>{TILE_NAMES[a]} <img alt=\"\" slot=\"suffix\" src={this.state.builtTileImages[a]}></img> </SlMenuItem>)}\n                </SlSelect>\n              </div>\n\n              {TILE_OPTIONS[this.state.tileType].map(setting => \n                <TileSetting \n                  key={this.state.tileType + setting.name}\n                  setting={setting} \n                  state={this.state} \n                  tileTypeId={this.state.tileType} \n                  updateTileState={(a, b, c) => this.updateTileState(a, b, c)\n                }></TileSetting>\n              )}\n            </div>\n          </div>\n        </section>\n        <footer>\n          <p>\n            Heavily inspired by <a href=\"https://0x72.itch.io/2bitcharactergenerator\" target=\"_blank\">0x72's 2BitCharactersGenerator</a>. \n            UI powered by <a href=\"https://shoelace.style/\" target=\"_blank\">Shoelace</a>.\n          </p>\n\n          <p>\n            All images generated by this tool are free for use. (CC0) Tool available under the MIT license. (\n            <a href=\"https://github.com/cppchriscpp/2bit-tile-generator\" target=\"_blank\">Source</a>  {' '}\n            <a href=\"https://github.com/cppchriscpp/2bit-tile-generator/issues\" target=\"_blank\">Feature Requests</a>) \n            </p>\n          <p>\n            There is no requirement to credit me, but please consider tweeting me if you find this useful! {' '}\n            <a href=\"https://twitter.com/cppchriscpp\" target=\"_blank\">@cppchriscpp</a>\n          </p>\n          <p>Wanna see the other stuff I do? Check out <a href=\"https://cpprograms.net\" target=\"_blank\">cpprograms.net</a>.</p>\n          <SlTooltip content=\"Click for changelog\">\n            <a className=\"version\" href=\"https://github.com/cppchriscpp/2bit-tile-generator/blob/main/CHANGELOG.md\" target=\"_blank\">version {process.env.REACT_APP_VERSION}</a>\n          </SlTooltip>\n        </footer>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import Jimp from 'jimp/es';\n\nimport { TILE_BACKGROUND_COLORS, IMAGE_WIDTH, IMAGE_HEIGHT, AVAILABLE_TILE_TYPES, TILE_PREVIEW_MAP } from '../constants/tile-constants';\n\n// Because js treats % as a remainder instead of modulus... because, sigh, programming languages were a mistake.\nfunction modulus(a, b) {\n  return ((a % b ) + b) % b;\n}\n\n// Helper to find a random position within the image\nfunction getRandomImageCoords(image) {\n  let x = Math.floor(Math.random() * image.bitmap.width);\n  let y = Math.floor(Math.random() * image.bitmap.height);\n\n  return {x, y};\n}\n\n\n/**\n * Image generation logic. Used to generate all of the various images using Jimp.\n * Define available image types in the constants in ../tile-constants\n * \n * Jimp doesn't have any primitive drawing ability, and I can't find a library to do it. Maybe I'll make one by myself, but until\n * such a time, things are done manually here. (and very, very clumsily)\n */\nexport default class ImageGenerator {\n  // Really just a home for static methods for now. Don't even construct it.\n\n  static generateImage(tileType, tileOpt, palette) {\n    // Jimp isn't super promise friendly - technically it works but it's pretty sketchy at times. Wrap this instead.\n    return new Promise((resolve, reject) =>{\n      new Jimp(IMAGE_WIDTH, IMAGE_HEIGHT, palette[TILE_BACKGROUND_COLORS[tileType]], async (err, image) =>{\n        if (err) { reject(err); }\n\n        // Big, kind of ugly switch statement for each of our available tile types, determining how to draw each one.\n        switch (tileType) {\n          case 'grass': \n          await ImageGenerator.drawGrass(image, tileOpt, palette);\n            break;\n          case 'water':\n            await ImageGenerator.drawWater(image, tileOpt, palette);\n            break;\n          case 'brick':\n            await ImageGenerator.drawBrick(image, tileOpt, palette);\n            break;\n          case 'tile':\n          case 'block':\n            await ImageGenerator.drawBlock(image, tileOpt, palette);\n            break;\n          case 'hole':\n            await ImageGenerator.drawHole(image, tileOpt, palette);\n            break;\n          case 'plant':\n            await ImageGenerator.drawPlant(image, tileOpt, palette);\n            break;\n          case 'rock':\n            await ImageGenerator.drawRock(image, tileOpt, palette);\n            break;\n          case 'lava':\n            await ImageGenerator.drawLava(image, tileOpt, palette);\n            break;\n          case 'sand':\n            await ImageGenerator.drawSand(image, tileOpt, palette);\n            break;\n          case 'bridge':\n            await ImageGenerator.drawBridge(image, tileOpt, palette);\n            break;\n          case 'ladder':\n            await ImageGenerator.drawLadder(image, tileOpt, palette);\n            break;\n          case 'stairs':\n            await ImageGenerator.drawStairs(image, tileOpt, palette);\n            break;\n          default: \n            console.warn('Unimplemented tile type given!', tileType, 'blank image ahoy');\n        }\n\n        image.getBase64Async('image/png').then(resolve, reject);\n      });\n\n\n    });\n  }\n\n  static drawGrass(image, tileOpt, palette) {\n    for (let i = 0; i < tileOpt['Short Blades']; i++) {\n      const {x, y} = getRandomImageCoords(image);\n      image.setPixelColor(palette[2], x, y);\n    }\n    for (let i = 0; i < tileOpt['Tall Blades']; i++) {\n      const {x, y} = getRandomImageCoords(image);\n      image.setPixelColor(palette[2], x, y);\n      image.setPixelColor(palette[2], x, y === 0 ? (image.bitmap.height - 1) : y-1);\n    }\n\n    for (let i = 0; i < tileOpt['Triangles']; i++) {\n      const {x, y} = getRandomImageCoords(image);\n\n      image.setPixelColor(palette[2], x > 0 ? x-1 : (image.bitmap.width - 1), y);\n      image.setPixelColor(palette[2], x < (image.bitmap.width - 1) ? x+1 : 0, y);\n      image.setPixelColor(palette[2], x, y > 0 ? y-1 : (image.bitmap.height - 1));\n    }\n  }\n\n  static drawWater(image, tileOpt, palette) {\n    for (let i = 0; i < tileOpt['Deeper Areas']; i++) {\n      const {x: originX, y: originY} = getRandomImageCoords(image);\n      const depthR = Math.floor(Math.random() * 4) + 3;\n\n      image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y, idx) => {\n        const dx = originX - x;\n        const dy = originY - y;\n        if (dx*dx + dy*dy <= (depthR*depthR)) {\n          image.setPixelColor(palette[1], x, y);\n        }\n      });\n    }\n    for (let i = 0; i < tileOpt['Lines']; i++) {\n      const {x: originX, y: originY} = getRandomImageCoords(image);\n      const xDiff = Math.floor(Math.random() * 2) === 1 ? 1 : -1;\n      const yDiff = Math.floor(Math.random() * 2) === 1 ? 1 : -1;\n      let x = originX, y = originY;\n      image.setPixelColor(palette[3], x, y);\n      x = modulus(x + xDiff, image.bitmap.width);\n      y = modulus(y + yDiff, image.bitmap.height);\n      while (x !== originX && y !== originY) {\n        image.setPixelColor(palette[3], x, y);\n        if (Math.random() > 0.3) {\n          x = modulus(x + xDiff, image.bitmap.width);\n        }\n        if (Math.random() > 0.3) {\n          y = modulus(y + yDiff, image.bitmap.height);\n        }\n\n      }\n      image.setPixelColor(palette[3], x, y);\n    }\n\n  }\n\n  static drawBrick(image, tileOpt, palette) {\n    const row1Lines = [];\n    const row2Lines = [];\n    for (var i = 0; i < image.bitmap.width; i++) {\n      if (modulus(i+1, tileOpt['Brick Width'] + 1) === 0) {\n        row1Lines.push(i);\n      } else if (modulus(i + 1 + Math.floor(tileOpt['Brick Width'] / 2), tileOpt['Brick Width'] + 1) === 0) {\n        row2Lines.push(i);\n      }\n    }\n\n    // Fill with bg color to start\n    let rowNum = 0;\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y, idx) => {\n      image.setPixelColor(palette[tileOpt['Brick Color']], x, y);\n\n      if (y % (tileOpt['Brick Height'] + 1) === 0) {\n        image.setPixelColor(palette[0], x, y);\n        if (x === 0) { ++rowNum; }\n      }\n\n      if (rowNum % 2 === 0) {\n        if (row1Lines.indexOf(x) !== -1) {\n          image.setPixelColor(palette[0], x, y);\n        }\n      } else {\n        if (row2Lines.indexOf(x) !== -1) {\n          image.setPixelColor(palette[0], x, y);\n        }\n      }\n    });\n\n  }\n\n  static drawBlock(image, tileOpt, palette) {\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      const tileSize = (10 - tileOpt['Height']) * 2;\n\n      image.setPixelColor(x > (image.bitmap.height - y - 1) ? palette[1] : palette[3], x, y);\n\n      \n      if (x === y) {\n        image.setPixelColor(palette[2], x, y);\n      } else if (x === (image.bitmap.height - y - 1)) {\n        image.setPixelColor(palette[1], x, y);\n      }\n      const h = ((image.bitmap.height / 2) - (tileSize / 2));\n      \n      if (x > h && x < (h + tileSize - 1)) {\n        if (y > h && y < (h + tileSize - 1)) {\n          image.setPixelColor(palette[2], x, y);\n        }\n      }\n    });\n  }\n\n  static drawHole(image, tileOpt, palette) {\n    const borderWidth = Math.floor((image.bitmap.width / 2) - (tileOpt['Hole Size'] / 2));\n    const fuzzWidth = tileOpt['Fuzz Area'];\n\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      if (\n        (x < borderWidth || x > (image.bitmap.width - 1 - borderWidth)) ||\n        (y < borderWidth || y > (image.bitmap.height - 1 - borderWidth))\n      ) {\n        \n        if (\n          (x >= (borderWidth - fuzzWidth) && x < borderWidth && (y > borderWidth && y < (image.bitmap.height - 1 - borderWidth))) ||\n          (x >= (borderWidth + tileOpt['Hole Size']) && x < (borderWidth + tileOpt['Hole Size'] + fuzzWidth) && (y > borderWidth && y < (image.bitmap.height -1 - borderWidth))) ||\n          \n          (y >= (borderWidth - fuzzWidth) && y < borderWidth && (x > borderWidth && x < (image.bitmap.width - 1 - borderWidth))) ||\n          (y >= (borderWidth + tileOpt['Hole Size']) && y < (borderWidth + tileOpt['Hole Size'] + fuzzWidth) && (x > borderWidth && x < (image.bitmap.width -1 - borderWidth)))\n        ) {\n          // Bail some of the time to make it \"fuzzy\"\n          if (Math.random() > 0.35) { return; }\n        }\n        image.setPixelColor(palette[2], x, y);\n      }\n    });\n\n  }\n\n  // NOTE: I really don't like the results of this, it needs a rewrite. Maybe someone can use it, but it feels lackluster at best. \n  // I'm not sure what else I can really do procedurally, or even non-procedurally. PRs welcome, with either code or even a 16x16 image\n  // and some notes on how we could tweak it. \n  static drawPlant(image, tileOpt, palette) {\n\n    // Draw that circle\n    const r = tileOpt['Bush Size'];\n    const x = 8, y = 10 - Math.floor(tileOpt['Bush Size'] / 2);\n    \n    let angle, x1, y1;\n    for (var i = 0; i < 360; i++) {\n      angle = i;\n      x1 = r * Math.cos(angle * Math.PI / 180);\n      y1 = r * Math.sin(angle * Math.PI / 180);\n\n      image.setPixelColor(palette[0], Math.round(x + x1), Math.round(y + y1));\n    }\n\n    // terribly simple color filling algorithm\n    for (var imgY = 0; imgY < image.bitmap.height; imgY++) {\n      let hitLeft = false, hitMid = false, hitRight = false, colorCount = 0;\n      for (var imgX = 0; imgX < image.bitmap.width; imgX++) {\n        if (image.getPixelColor(imgX, imgY) === palette[0]) {\n          colorCount++;\n          if (!hitLeft) {\n            hitLeft = true;\n          } else if (hitMid) {\n            hitRight = true;\n          }\n        } else {\n          if (hitLeft && image.getPixelColor(imgX, imgY) === palette[3]) {\n            hitMid = true;\n          }\n          if (hitMid && !hitRight && colorCount < 5) { // Must be on the inside of the circle\n            image.setPixelColor(palette[tileOpt['Bush Color']], imgX, imgY);\n          }\n        }\n      }\n    }\n\n    // Draw small shadow\n    for (let shadowX = x - Math.floor(r/2)+1; shadowX < x + r+1; shadowX++) {\n      image.setPixelColor(palette[0], shadowX, y + r + 1);\n      if (shadowX < x + r) {\n        image.setPixelColor(palette[0], shadowX, y + r);\n      }\n    }\n\n    // Pick a few random spots to draw berries/freckles/whatever\n    let freckleCount = 0;\n    for (var i = 0; i < 100; i++) { // Limit # of tries to make, just in case \n      if (freckleCount >= tileOpt['Freckle Count']) {\n        break;\n      }\n\n      const fx = Math.floor(Math.random() * (image.bitmap.width)),\n        fy = Math.floor(Math.random() * image.bitmap.height);\n\n      if (image.getPixelColor(fx,fy) === palette[tileOpt['Bush Color']]) {\n        freckleCount++;\n        image.setPixelColor(palette[tileOpt['Freckle Color']], fx, fy);\n\n        if (tileOpt['Freckle Size'] > 1) {\n          [[fx-1, fy], [fx+1,fy], [fx, fy-1], [fx, fy+1]].forEach(coords => {\n            const fxx = coords[0], fyy = coords[1];\n            if (image.getPixelColor(fxx, fyy) === palette[tileOpt['Bush Color']]) {\n              image.setPixelColor(palette[tileOpt['Freckle Color']], fxx, fyy);\n            }\n          });\n        }\n      }\n    }\n  }\n\n  static async drawRock(image, tileOpt, palette) {\n\n    // Create a copy for us to play with, so we can mess with location\n    const rockImg = await Jimp.read(image);\n\n    const r = tileOpt['Rock Size'];\n    const x = 8, y = rockImg.bitmap.height - (tileOpt['Rock Size'] - 2);\n    let angle, x1, y1;\n    for (var i = 0; i < 360; i++) {\n      angle = i;\n      x1 = r * Math.cos(angle * Math.PI / 180);\n      y1 = r * Math.sin(angle * Math.PI / 180);\n\n      rockImg.setPixelColor(palette[0], Math.round(x + x1), Math.round(y + y1));\n    }\n\n    // terribly simple color filling algorithm\n    for (var imgY = 0; imgY < rockImg.bitmap.height; imgY++) {\n      let hitLeft = false, hitMid = false, hitRight = false, colorCount = 0;\n      for (var imgX = 0; imgX < rockImg.bitmap.width; imgX++) {\n        if (rockImg.getPixelColor(imgX, imgY) === palette[0]) {\n          colorCount++;\n          if (!hitLeft) {\n            hitLeft = true;\n          } else if (hitMid) {\n            hitRight = true;\n          }\n        } else {\n          if (hitLeft && rockImg.getPixelColor(imgX, imgY) === palette[3]) {\n            hitMid = true;\n          }\n          if (hitMid && !hitRight && colorCount < 5) { // Must be on the inside of the circle\n            if ((imgX - imgY) < r - Math.floor(r/1.2)) {\n              rockImg.setPixelColor(palette[tileOpt['Rock Color']], imgX, imgY);\n            } else {\n              rockImg.setPixelColor(palette[tileOpt['Rock Highlight Color']], imgX, imgY);\n            }\n          }\n        }\n      }\n    }\n\n    // okay, the image is done, but not really centered how we'd like. Blit the image onto itself?\n    await image.blit(rockImg, 0, -1 - Math.floor((image.bitmap.height / 2) - (tileOpt['Rock Size'])));\n  }\n\n  static async drawLava(image, tileOpt, palette) {\n    const frequency = (tileOpt['Frequency'] / 100),\n      offset = tileOpt['Offset'],\n      waveWidth = tileOpt['Wave Width'];\n    for (let y = 0; y < image.bitmap.width; y++) {\n      let x = Math.sin((frequency * (Math.abs(y-offset) % image.bitmap.width)) ) * Math.floor(image.bitmap.height / 3);\n\n\n      while (x < image.bitmap.width) {\n        // Set a dummy color to replace\n        image.setPixelColor(0xff00ffff, x, y);\n        x += waveWidth;\n      }\n\n      // Repeat iterating over the whole thing, swapping colors\n      let currColor = 1;\n      for (x = 0; x < image.bitmap.width; x++) {\n        if (image.getPixelColor(x, y) === 0xff00ffff) {\n          currColor = 1+((currColor + 1) % 3);\n        }\n        image.setPixelColor(palette[currColor], x, y);\n      }\n    }\n  }\n\n  static async drawSand(image, tileOpt, palette) {\n    const frequency = (tileOpt['Frequency'] / 100),\n      offset = tileOpt['Offset'],\n      waveWidth = tileOpt['Wave Width'];\n    for (let y = 0; y < image.bitmap.width; y++) {\n      let x = Math.sin((frequency * (Math.abs(y-offset) % image.bitmap.width)) ) * Math.floor(image.bitmap.height / 3);\n\n\n      while (x < image.bitmap.width) {\n        // Set a dummy color to replace\n        image.setPixelColor(0xff00ffff, x, y);\n        x += waveWidth;\n      }\n\n      // Repeat iterating over the whole thing, swapping colors\n      let currColor = 2;\n      for (x = 0; x < image.bitmap.width; x++) {\n        if (image.getPixelColor(x, y) === 0xff00ffff) {\n          currColor = 2+((currColor + 1) % 2);\n        }\n        image.setPixelColor(palette[currColor], x, y);\n      }\n    }\n  }\n\n  static async drawBridge(image, tileOpt, palette) {\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      if (x % (tileOpt['Board Width']+1) === 0 || y < tileOpt['Border Width'] || y > (image.bitmap.width - tileOpt['Border Width'] - 1)) {\n        image.setPixelColor(palette[tileOpt['Separator Color']], x, y);\n      } else {\n        image.setPixelColor(palette[tileOpt['Board Color']], x, y);\n      }\n    })\n  }\n\n  static async drawLadder(image, tileOpt, palette) {\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      if (y % (tileOpt['Step Width']+1) === 0 || x < tileOpt['Border Width'] || x > (image.bitmap.width - tileOpt['Border Width'] - 1)) {\n        image.setPixelColor(palette[tileOpt['Separator Color']], x, y);\n      } else {\n        image.setPixelColor(palette[tileOpt['Step Color']], x, y);\n      }\n    })\n  }\n\n  static async drawStairs(image, tileOpt, palette) {\n    image.scan(0, 0, image.bitmap.width, image.bitmap.height, (x, y) => {\n      let stepHeight = Math.floor((x-1) / tileOpt['Step Width']) * tileOpt['Step Height'];\n      if (\n        x % (tileOpt['Step Width']+1) === 0 || \n        y < tileOpt['Border Width'] +  stepHeight || \n        y > (image.bitmap.width - tileOpt['Border Width'] - 1)\n      ) {\n        image.setPixelColor(palette[tileOpt['Separator Color']], x, y);\n      } else {\n        image.setPixelColor(palette[tileOpt['Step Color']], x, y);\n      }\n    })\n  }\n\n\n  static generateFullSet(imageState) {\n    return new Promise((resolve, reject) =>{\n      new Jimp(IMAGE_WIDTH * (AVAILABLE_TILE_TYPES.length+1), IMAGE_HEIGHT, 0xffffffff, (err, image) =>{\n        if (err) { reject(err); }\n\n        // Force back into async context\n        (async () => {\n\n          // Loop over each available image type\n          for (let i = 0; i < AVAILABLE_TILE_TYPES.length; i++ ) {\n            let thisB64 = imageState[AVAILABLE_TILE_TYPES[i]];\n            thisB64 = thisB64.substr(thisB64.indexOf(',')+1);\n            let thisImg = await Jimp.read(Buffer.from(thisB64, 'base64'));\n            await image.blit(thisImg, (i+1)*IMAGE_WIDTH, 0);\n          }\n\n\n          return image.getBase64Async('image/png');\n        })().then(resolve, reject);\n\n      });\n\n\n    });\n  }\n\n  static generateMapPreview(imageState) {\n    const width = Math.sqrt(TILE_PREVIEW_MAP.length);\n    return new Promise((resolve, reject) =>{\n      // Dealing with Jimp's weird promise quirks (again)\n      new Jimp(IMAGE_WIDTH * width, IMAGE_HEIGHT * width, 0xffffffff, (err, image) =>{\n        if (err) { reject(err); }\n\n        // Force back into async context\n        (async () => {\n\n          // Build up the LUT of actual images, since we should use all of em\n          let tileImages = {};\n          let drawState = {};\n          for (let i = 0; i < AVAILABLE_TILE_TYPES.length; i++) {\n            let thisB64 = imageState[AVAILABLE_TILE_TYPES[i]];\n            thisB64 = thisB64.substr(thisB64.indexOf(',')+1);\n            tileImages[AVAILABLE_TILE_TYPES[i]] = await Jimp.read(Buffer.from(thisB64, 'base64'));\n            drawState[AVAILABLE_TILE_TYPES[i]] = false;\n          }\n\n          for (var x = 0; x < width; x++) {\n            for (var y = 0; y < width; y++) {\n              const pos = y*width + x;\n              image.blit(tileImages[TILE_PREVIEW_MAP[pos]], x * IMAGE_WIDTH, y * IMAGE_HEIGHT);\n              drawState[TILE_PREVIEW_MAP[pos]] = true;\n            }\n          }\n\n          // Check which tiles were not drawn, print a warning.\n          const notDrawn = AVAILABLE_TILE_TYPES.filter(a => !drawState[a]);\n          if (notDrawn.length > 0) {\n            console.warn('Some tiles were not included in the preview!', notDrawn.join(', '));\n          }\n\n          return image.getBase64Async('image/png');\n        })().then(resolve, reject);\n\n      });\n\n    });\n\n  }\n}"],"sourceRoot":""}